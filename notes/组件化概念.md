# 为什么要组件化
　　随着技术的发展,开发的复杂度也越来越高,传统开发模式总是存在着开发效率低,维护成本高等等的弊端.传统开发方式效率低以及维护成本高的主要原因在于,很多情况下我们是将一个系统做成了整块应用,而随着业务的增长或者变更,系统的复杂度往往会呈现指数级的增长.经常出现的情况就是,一个小小的改动或者一个小功能的增加可能会引起整体逻辑的修改,造成牵一发而动全身.针对此弊端,**我们希望一个大且复杂的场景能够被分解成几个小的部分,这些小的部分彼此之间互不干扰,可以单独开发,单独维护,而且他们之间可以随意的进行组合**       
　　现代大型软件系统中,Web应用的前后端已经实现了分离.随着REST软件架构的发展,**在后端开发中的体现是微服务,在前端开发中的体现是组件化**    
　　以电脑主机来说,一台整机包括CPU,主板,内存,硬盘等,而这些部件其实都是由不同的公司进行生产的,他们彼此之间根据一套标准分别生产,最后组装在一起.当某个部件出现问题时,不需要将整台主机都进行维修,只需要将坏的部件拿下来,维修之后再将其组合上就可以了
* 微服务
  > 简单来说就是将一个大型后端服务,拆分成多个小服务,它们分别部署,降低了开发的复杂性,且提高了系统的可伸缩性   
  > 推荐: [RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)
* 组件化
  > `1.`标准性: 
  > 任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件
  > `2.`组合性: 
  > 组件之前应该是可以组合的。我们知道前端页面的展示都是一些HTML DOM的组合，而组件在最终形态上也可以理解为一个个的HTML片段。那么组成一个完整的界面展示，肯定是要依赖不同组件之间的组合，嵌套以及通信    
  > `3.`重用性: 
  > 任何一个组件应该都是一个可以独立的个体，可以使其应用在不同的场景中   
  > `4.`可维护性: 
  > 任何一个组件应该都具有一套自己的完整的稳定的功能，仅包含自身的，与其它组件无关的逻辑，使其更加的容易理解，使其更加的容易理解，同时大大减少发生bug的几率
_____________________________________________________________
# 组件
## 1. 组件定义
> 一个不透明的功能实体,能够被第三方组装,且符合一个构件模型
## 2. 组件分类
* 复合组件（Composite Controls）
  > 将现有的各种组件组合起来,形成一个新的组件,将多个组件的性能集中起来
* 扩展组件（Extended Controls）
  > 在现有组件的基础上派生出一个新的组件,为原有组件增加新的性能或者更改原有组件的功能
* 自定义组件（Custom Controls）
  > 自行设计并制作出一个不透明的功能实体,并提供可用的接口
## 3. 产生背景
> 　　组件是近代工业发展的产物,兴起于20世纪初,目的是功能模块化,前提是接口标准化,好处是构成产品的各个功能组件,由更专业的厂商生产,提高了质量,降低了成本
> 而生产组件的厂商,同样的组件,可应用于多类产品和多个领域,极大地扩展了市场范围
_____________________________________________________________
## 组件化目的
* 大型团队的协同合作
## 组件化的缘由
* 几乎所有的码农写代码,都以自我为中心
* JS是单线程的,CSS是全局的,几个人一起搞,一个bug全家玩完
## 特点
* 内聚性
  > 你怎么写代码我不管,你的功能全在这你这儿实现
* 低耦合性
  > 你代码请一定不要影响我的代码
## 特点衍生的框架
YUI, ExtJS, web component
_____________________________________________________________
# web component
_____________________________________________________________
## 1. 影子DOM (shadow dom)   
* 使用控件的时候并不关心控件的内部结构,只关心控件的本身,所以需要一种方式来将内部的信息封装起来
* 封装起来信息只有在特定场合才能看见,方便DOM的遍历,比如h5的video标签
* 创建Shadow DOM: 通过`createShadowRoot`函数对一个`DOM 元素（宿主元素)`创建一个`Shadow DOM子树`
* 渲染影子DOM的div的样式，使用(Pseudo Selector)伪类选着器:
```css
  video::-webkit-media-controls-panel{    
        background-color: red;    
  }
```
## 2. 自定义元素（Custom Elements）   
* 注册
  > 有生命周期,有自己的脚本行为和CSS样式.它们是Web组件的一部分,但也可以自己单独使用    
  > `1. 创建对象`   
  > `2. 定义对象属性`   
  > `3. 定义生命周期方法`   
  > `4. 注册新元素`    
* 非注册
  > 没有生命周期 
## 3. template
* 用于保存客户端内容的机制,该内容在页面加载时不被渲染,但可以在运行时使用JavaScript进行实例化
* 可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段
* 在加载页面的同时,解析器会处理`<template>`元素的内容,但只是确保这些内容是有效的,元素的内容不会被渲染    
* 创建一个template的 html 标签，通过 javascript 获取节点的模板内容   
```javaScript
模板默认不显示，需要激活模板，通过以下两种方法来激活节点
   1. 克隆节点:
　　  var templateContent  = template.content;
　　  var activeNode = templateContent.cloneNode(true);
　　  document.body.appendChild(activeNode);
   2. 导入节点
　　  var templateContent  = template.content;
　　  var activeNode = document.importNode(templateContent,true);
　　  document.body.appendChild(activeNode);
```
## 4. import
* Html Import 可以将外部的 HTML 文档嵌入到当前文档中，提供很好的资源共享        
* 带有import属性的link 支持两个事件      
  > `1. onload：文件成功引入页面会触发`   
  > `2. onerror：文件加载失败会触发`    
## 5. 例
```javaScript
　　<link rel="import" href="banner.html">
　　<link rel="import" href="phones.html">
　　<link rel="import" href="list.html">
　　<template name="t-listBox">
    　　<t-banner></t-banner>
    　　<t-phone></t-phone>
    　　<t-list></t-list>
　　</template>
```
