# 组件化思想的必要性

## 传统模式的弊端
* 开发效率低,维护成本高
* 效率低以及维护成本高的主要原因在于,很多情况下我们是将一个系统做成了整块应用,而随着业务的增长或者变更,系统的复杂度往往会呈现指数级的增长.经常出现的情况就是,一个小小的改动或者一个小功能的增加可能会引起整体逻辑的修改,造成牵一发而动全身.
## 为什么要组件化
* 我们希望一个大且复杂的场景能够被分解成几个小的部分,这些小的部分彼此之间互不干扰,可以单独开发,单独维护,可以随意的进行组合,可应用在多个地方
* 几乎所有人,都以自我为中心,为了团队能够更高效率的协同合作,公司内部团队与团队之间,个人与个人之间,代码与代码之间,都应该是一个不透明的功能体(黑盒子),只需要提供一个可用的构件模式(接口)
* 例: 以电脑主机来说,一台整机包括CPU,主板,内存,硬盘等,而这些部件其实都是由不同的公司进行生产的,他们彼此之间根据一套标准分别生产,最后组装在一起.当某个部件出现问题时,不需要将整台主机都进行维修,只需要将坏的部件拿下来,维修之后再将其组合上就可以了
## 特点
* 内聚性
  > 你怎么工作我不管,你的功能全在这你这儿实现
* 低耦合性
  > 你的功能请一定不要影响我的功能
## 当前形式
* 现代大型软件系统中,Web应用的前后端已经实现了分离,网页即软件
* 随着[REST](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)软件架构的发展,在后端开发中的体现是[微服务](#),在前端开发中的体现是[组件化](#)
  > 简单点说就是把一个整体进行合理分割,现行的所有方法都是为了合理分割
## 前后端沟通方式(协议)
  > 推荐阮一峰的[RESTful API 设计指南](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)
## 微服务
  > 简单来说就是将一个大型后端服务,拆分成多个小服务,它们分别部署,降低了开发的复杂性,且提高了系统的可伸缩性    
  > 后端将所有最细粒度的数据资源全部开放出去,至于业务逻辑将来要怎样使用,就不管了,业务复杂度全部交由前端处理
## 组件化
* 标准性
  > 任何一个组件都应该遵守一套标准，可以使得不同区域的开发人员据此标准开发出一套标准统一的组件
* 组合性
  > 组件之前应该是可以组合的。我们知道前端页面的展示都是一些HTML DOM的组合，而组件在最终形态上也可以理解为一个个的HTML片段。那么组成一个完整的界面展示，肯定是要依赖不同组件之间的组合，嵌套以及通信
* 重用性
  > 任何一个组件应该都是一个可以独立的个体，可以使其应用在不同的场景中
* 可维护
  > 任何一个组件应该都具有一套自己的完整的稳定的功能，仅包含自身的，与其它组件无关的逻辑，使其更加的容易理解，使其更加的容易理解，同时大大减少发生bug的几率
____________________________________________________________
# 组件
## 1. 组件定义
> 一个不透明的功能实体,能够被第三方组装,且符合一个构件模型
## 2. 组件分类
* 复合组件（Composite Controls）
  > 将现有的各种组件组合起来,形成一个新的组件,将多个组件的性能集中起来
* 扩展组件（Extended Controls）
  > 在现有组件的基础上派生出一个新的组件,为原有组件增加新的性能或者更改原有组件的功能
* 自定义组件（Custom Controls）
  > 自行设计并制作出一个不透明的功能实体,并提供可用的接口
## 衍生的框架
YUI, ExtJS, [web component](https://github.com/nqey/study-note/blob/master/notes/webComponent.md#web-component)
